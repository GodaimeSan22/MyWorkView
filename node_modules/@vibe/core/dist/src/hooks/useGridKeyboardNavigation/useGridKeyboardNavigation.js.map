{"version":3,"file":"useGridKeyboardNavigation.js","sources":["../../../../src/hooks/useGridKeyboardNavigation/useGridKeyboardNavigation.ts"],"sourcesContent":["import { MutableRefObject, ReactElement, useCallback, useContext, useEffect, useRef, useState } from \"react\";\nimport { GridKeyboardNavigationContext } from \"../../components/GridKeyboardNavigationContext/GridKeyboardNavigationContext\";\nimport useFullKeyboardListeners, { NavDirections } from \"../../hooks/useFullKeyboardListeners\";\nimport useEventListener from \"../../hooks/useEventListener\";\nimport {\n  calcActiveIndexAfterArrowNavigation,\n  getActiveIndexFromInboundNavigation\n} from \"./gridKeyboardNavigationHelper\";\nimport { useLastNavigationDirection } from \"../../components/Menu/Menu/hooks/useLastNavigationDirection\";\n\nconst NO_ACTIVE_INDEX = -1;\n\n/**\n * A hook which is used for accessible keyboard navigation. Useful for components rendering a list of items that can be navigated and selected with a keyboard.\n * @param {Object} options\n * @param {React.MutableRefObject} options.ref - the reference for the component that listens to keyboard\n * @param {number} options.itemsCount - the number of items\n * @param {number} options.numberOfItemsInLine - the number of items on each line of the grid\n * @param {function} options.onItemClicked - the callback for selecting an item. It will be called when an active item is selected, for example with \"Enter\".\n * @param {function} options.getItemByIndex - a function which gets an index as a param, and returns the item on that index\n * @param {\"directional\" | \"first\"} options.entryFocusStrategy - Determines how the first item is focused when entering the grid via keyboard.\n *   - \"directional\": Tries to focus based on the entry direction (Tab vs Shift+Tab). This is the default.\n *   - \"first\": Always focuses the first item.\n * @param {boolean=} options.focusOnMount - if true, the referenced element will be focused when mounted\n * @param {number=} options.focusItemIndexOnMount - optional item index to focus when mounted. Only works with \"options.focusOnMount\".\n * @param {number[]=} options.disabledIndexes - optional array of disabled indices, which will be skipped while navigating.\n * @param {boolean=} options.circularNavigation - if true, the navigation will wrap around the grid\n * @returns {useGridKeyboardNavigationResult}\n *\n * @typedef useGridKeyboardNavigationResult\n * @property {number} activeIndex - the currently active index\n * @property {boolean} isInitialActiveState - if true, the currently active element was due to an initial mounting index option. See \"options.focusItemIndexOnMount\".\n * @property {(index: number, isKeyboardAction?: boolean) => void} onSelectionAction - the callback which should be used to select an item.\n * It should be called with the selected item's index. Use this callback for onClick handlers, for example.\n * The \"isKeyboardAction\" can be used to indicate a keyboard selection, which will affect the currently active index.\n */\nexport default function useGridKeyboardNavigation({\n  ref,\n  itemsCount,\n  numberOfItemsInLine,\n  onItemClicked, // the callback to call when an item is selected\n  entryFocusStrategy = \"directional\",\n  getItemByIndex = (_index: number) => {},\n  focusOnMount = false,\n  focusItemIndexOnMount = NO_ACTIVE_INDEX,\n  disabledIndexes = [],\n  circularNavigation = false\n}: {\n  ref: MutableRefObject<HTMLElement>;\n  itemsCount: number;\n  numberOfItemsInLine: number;\n  onItemClicked: (element: HTMLElement | ReactElement | void | string, index: number) => void;\n  entryFocusStrategy?: \"directional\" | \"first\";\n  getItemByIndex: (index: number | void) => HTMLElement | ReactElement | void | string;\n  focusOnMount?: boolean;\n  focusItemIndexOnMount?: number;\n  disabledIndexes?: number[];\n  circularNavigation?: boolean;\n}) {\n  const [isInitialActiveState, setIsInitialActiveState] = useState(\n    focusOnMount && focusItemIndexOnMount !== NO_ACTIVE_INDEX\n  );\n  const skippedInitialActiveIndexChange = useRef(false);\n  const [activeIndex, setActiveIndex] = useState(isInitialActiveState ? focusItemIndexOnMount : NO_ACTIVE_INDEX);\n  const [isUsingKeyboardNav, setIsUsingKeyboardNav] = useState(true);\n\n  const keyboardContext = useContext(GridKeyboardNavigationContext);\n\n  const onArrowNavigation = (direction: NavDirections) => {\n    setIsUsingKeyboardNav(true);\n    if (activeIndex === NO_ACTIVE_INDEX) {\n      setActiveIndex(0);\n      return;\n    }\n\n    const { isOutbound, nextIndex } = calcActiveIndexAfterArrowNavigation({\n      activeIndex,\n      itemsCount,\n      numberOfItemsInLine,\n      direction,\n      disabledIndexes,\n      circularNavigation\n    });\n    if (isOutbound) {\n      keyboardContext?.onOutboundNavigation(ref, direction);\n    } else {\n      setActiveIndex(nextIndex);\n    }\n  };\n\n  useEffect(() => {\n    if (!skippedInitialActiveIndexChange.current) {\n      skippedInitialActiveIndexChange.current = true;\n      return;\n    }\n    // if the active state changes, this is no longer the initial active state\n    setIsInitialActiveState(false);\n  }, [activeIndex]);\n\n  const blurTargetElement = useCallback(() => ref.current?.blur(), [ref]);\n\n  const { lastNavigationDirectionRef } = useLastNavigationDirection();\n  const onFocus = useCallback(() => {\n    if (activeIndex !== NO_ACTIVE_INDEX) {\n      setIsUsingKeyboardNav(true);\n      return;\n    }\n\n    const direction = lastNavigationDirectionRef.current;\n    setActiveIndex(\n      entryFocusStrategy === \"directional\" && direction\n        ? getActiveIndexFromInboundNavigation({ direction, numberOfItemsInLine, itemsCount })\n        : 0\n    );\n    setIsUsingKeyboardNav(true);\n  }, [\n    activeIndex,\n    entryFocusStrategy,\n    itemsCount,\n    lastNavigationDirectionRef,\n    numberOfItemsInLine,\n    setActiveIndex,\n    setIsUsingKeyboardNav\n  ]);\n\n  const onMouseDown = useCallback(() => {\n    // If the user clicked on the grid element we assume that that what will caused the focus\n    setIsUsingKeyboardNav(false);\n  }, [setIsUsingKeyboardNav]);\n\n  const onBlur = useCallback(() => {\n    // If we lose focus we will return to isUsingKeyboardNav default mode which is that any interaction\n    // with the grid always done by keyboard, unless we clicked on the grid element before that with a mouse\n    setIsUsingKeyboardNav(true);\n    setActiveIndex(NO_ACTIVE_INDEX);\n  }, [setActiveIndex]);\n\n  useEventListener({ eventName: \"focus\", callback: onFocus, ref });\n  useEventListener({ eventName: \"mousedown\", callback: onMouseDown, ref });\n  useEventListener({ eventName: \"blur\", callback: onBlur, ref });\n\n  useEffect(() => {\n    if (activeIndex > -1) {\n      ref.current?.focus();\n    }\n  }, [activeIndex, ref]);\n\n  const onSelectionAction = useCallback(\n    (index: number, isKeyboardAction = false) => {\n      setIsUsingKeyboardNav(isKeyboardAction);\n      setActiveIndex(index);\n\n      onItemClicked(getItemByIndex(index), index);\n    },\n    [setActiveIndex, onItemClicked, getItemByIndex]\n  );\n\n  const onKeyboardSelection = useCallback(() => {\n    if (!isUsingKeyboardNav) {\n      return;\n    }\n    return onSelectionAction(activeIndex, true);\n  }, [isUsingKeyboardNav, onSelectionAction, activeIndex]);\n\n  useFullKeyboardListeners({\n    ref,\n    onSelectionKey: onKeyboardSelection,\n    onArrowNavigation,\n    onEscape: blurTargetElement,\n    focusOnMount\n  });\n\n  // if the user is not using keyboard nav, the consumers should not treat the index as active\n  const externalActiveIndex = isUsingKeyboardNav ? activeIndex : NO_ACTIVE_INDEX;\n  return {\n    activeIndex: externalActiveIndex,\n    onSelectionAction,\n    isInitialActiveState\n  };\n}\n"],"names":["NO_ACTIVE_INDEX","useGridKeyboardNavigation","_ref","ref","itemsCount","numberOfItemsInLine","onItemClicked","_ref$entryFocusStrate","entryFocusStrategy","_ref$getItemByIndex","getItemByIndex","_index","_ref$focusOnMount","focusOnMount","_ref$focusItemIndexOn","focusItemIndexOnMount","_ref$disabledIndexes","disabledIndexes","_ref$circularNavigati","circularNavigation","_useState","useState","_useState2","_slicedToArray","isInitialActiveState","setIsInitialActiveState","skippedInitialActiveIndexChange","useRef","_useState3","_useState4","activeIndex","setActiveIndex","_useState5","_useState6","isUsingKeyboardNav","setIsUsingKeyboardNav","keyboardContext","useContext","GridKeyboardNavigationContext","useEffect","current","blurTargetElement","useCallback","_a","blur","lastNavigationDirectionRef","useLastNavigationDirection","onFocus","direction","getActiveIndexFromInboundNavigation","onMouseDown","onBlur","useEventListener","eventName","callback","focus","onSelectionAction","index","arguments","length","undefined","onKeyboardSelection","useFullKeyboardListeners","onSelectionKey","onArrowNavigation","_calcActiveIndexAfter","calcActiveIndexAfterArrowNavigation","nextIndex","isOutbound","onOutboundNavigation","onEscape"],"mappings":"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"}